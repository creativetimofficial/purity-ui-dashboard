{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport path from \"path\";\nimport execa from \"execa\";\nimport format from \"date-fns/format\";\nimport fromUnixTime from \"date-fns/fromUnixTime\";\nimport { addLeadingSlash, getEditUrl } from \"@docusaurus/utils\";\nimport { serialize } from \"next-mdx-remote/serialize\";\nimport matter from \"gray-matter\";\nimport slugger from \"github-slugger\";\nexport async function serializeMdx(source) {\n  const {\n    content,\n    data\n  } = matter(source);\n  const mdxSource = await serialize(content, {\n    // Optionally pass remark/rehype plugins\n    mdxOptions: {\n      remarkPlugins: [require(\"remark-autolink-headings\"), require(\"remark-emoji\"), require(\"remark-images\"), require(\"remark-slug\"), require(\"remark-toc\"), require(\"remark-unwrap-images\")]\n    },\n    scope: data\n  });\n  return {\n    source: mdxSource,\n    frontMatter: data\n  };\n}\nexport async function processFrontmatter(options) {\n  const {\n    path: mdxPath,\n    author,\n    tags = [],\n    baseEditUrl = null,\n    slug: _slug\n  } = options,\n        rest = _objectWithoutProperties(options, [\"path\", \"author\", \"tags\", \"baseEditUrl\", \"slug\"]); // read the file path\n\n\n  const filePath = path.join(process.cwd(), \"pages\", mdxPath); // get the last edited author and date\n\n  const lastEdited = await getLastEdited(filePath); // get headings\n\n  const headings = rest.mdxContent ? getTableOfContents(rest.mdxContent) : []; // get the edit url\n\n  const editUrl = getEditUrl(path.join(mdxPath), baseEditUrl); // get the slug\n\n  const slug = _slug || fileToPath(mdxPath);\n\n  const data = _objectSpread(_objectSpread({}, rest), {}, {\n    slug,\n    lastEdited,\n    headings,\n    editUrl,\n    author,\n    tags\n  });\n\n  return data;\n}\n\nfunction fileToPath(str) {\n  return addLeadingSlash(str.replace(\".mdx\", \"\"));\n} //see https://github.com/hashicorp/next-mdx-remote/issues/53#issuecomment-725906664\n\n\nexport function getTableOfContents(mdxContent) {\n  const regexp = new RegExp(/^(### |## )(.*)\\n/, \"gm\"); // @ts-ignore\n\n  const headings = [...mdxContent.matchAll(regexp)];\n  let tableOfContents = [];\n\n  if (headings.length) {\n    tableOfContents = headings.map(heading => {\n      const headingText = heading[2].trim();\n      const headingType = heading[1].trim() === \"##\" ? \"h2\" : \"h3\";\n      const headingLink = slugger.slug(headingText, false);\n      return {\n        text: headingText,\n        id: headingLink,\n        level: headingType\n      };\n    });\n  }\n\n  return tableOfContents;\n}\n/**\n * Format the last edited timestamp and author from git output\n */\n\nfunction getTimestampAndAuthor(str) {\n  if (!str) return null;\n  const GIT_COMMIT_TIMESTAMP_AUTHOR_REGEX = /^(\\d+), (.+)$/;\n  const temp = str.match(GIT_COMMIT_TIMESTAMP_AUTHOR_REGEX);\n  if (!temp || temp.length < 3) return null;\n  const [, timestamp, author] = temp;\n  const dateStr = fromUnixTime(+timestamp);\n  return {\n    date: format(dateStr, \"MMMM dd, yyyy\"),\n    author\n  };\n}\n/**\n * Gets the last edited timestamp and author from git\n * using `git log`\n *\n * %an = author name\n * %ct = committer date, UNIX timestamp\n *\n * @see https://git-scm.com/docs/git-log\n */\n\n\nasync function getLastEdited(filePath) {\n  try {\n    const {\n      stdout\n    } = await execa(\"git\", [\"log\", \"-1\", \"--format=%ct, %an\", filePath]);\n    return getTimestampAndAuthor(stdout);\n  } catch (error) {\n    console.error(error);\n    return null;\n  }\n}","map":{"version":3,"sources":["/Users/vladmihalache/Documents/GitHub/chakra-ui/website/src/utils/mdx-utils.ts"],"names":["path","execa","format","fromUnixTime","addLeadingSlash","getEditUrl","serialize","matter","slugger","serializeMdx","source","content","data","mdxSource","mdxOptions","remarkPlugins","require","scope","frontMatter","processFrontmatter","options","mdxPath","author","tags","baseEditUrl","slug","_slug","rest","filePath","join","process","cwd","lastEdited","getLastEdited","headings","mdxContent","getTableOfContents","editUrl","fileToPath","str","replace","regexp","RegExp","matchAll","tableOfContents","length","map","heading","headingText","trim","headingType","headingLink","text","id","level","getTimestampAndAuthor","GIT_COMMIT_TIMESTAMP_AUTHOR_REGEX","temp","match","timestamp","dateStr","date","stdout","error","console"],"mappings":"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","sourcesContent":["import path from \"path\"\nimport execa from \"execa\"\nimport format from \"date-fns/format\"\nimport fromUnixTime from \"date-fns/fromUnixTime\"\nimport { addLeadingSlash, getEditUrl } from \"@docusaurus/utils\"\nimport { Dict } from \"@chakra-ui/utils\"\nimport { serialize } from \"next-mdx-remote/serialize\"\nimport matter from \"gray-matter\"\nimport slugger from \"github-slugger\"\n\nexport async function serializeMdx(source: string) {\n  const { content, data } = matter(source)\n\n  const mdxSource = await serialize(content, {\n    // Optionally pass remark/rehype plugins\n    mdxOptions: {\n      remarkPlugins: [\n        require(\"remark-autolink-headings\"),\n        require(\"remark-emoji\"),\n        require(\"remark-images\"),\n        require(\"remark-slug\"),\n        require(\"remark-toc\"),\n        require(\"remark-unwrap-images\"),\n      ],\n    },\n    scope: data,\n  })\n  return {\n    source: mdxSource,\n    frontMatter: data,\n  }\n}\n\nexport async function processFrontmatter<Options extends Dict>(\n  options: Options,\n) {\n  const {\n    path: mdxPath,\n    author,\n    tags = [],\n    baseEditUrl = null,\n    slug: _slug,\n    ...rest\n  } = options\n\n  // read the file path\n  const filePath = path.join(process.cwd(), \"pages\", mdxPath)\n\n  // get the last edited author and date\n  const lastEdited = await getLastEdited(filePath)\n\n  // get headings\n  const headings = rest.mdxContent ? getTableOfContents(rest.mdxContent) : []\n\n  // get the edit url\n  const editUrl = getEditUrl(path.join(mdxPath), baseEditUrl)\n\n  // get the slug\n  const slug = _slug || fileToPath(mdxPath)\n\n  const data = {\n    ...rest,\n    slug,\n    lastEdited,\n    headings,\n    editUrl,\n    author,\n    tags,\n  }\n\n  return data as typeof data & Options & { slug?: string; date?: string }\n}\n\nfunction fileToPath(str: string) {\n  return addLeadingSlash(str.replace(\".mdx\", \"\"))\n}\n\n//see https://github.com/hashicorp/next-mdx-remote/issues/53#issuecomment-725906664\nexport function getTableOfContents(mdxContent: string) {\n  const regexp = new RegExp(/^(### |## )(.*)\\n/, \"gm\")\n  // @ts-ignore\n  const headings = [...mdxContent.matchAll(regexp)]\n  let tableOfContents = []\n\n  if (headings.length) {\n    tableOfContents = headings.map((heading) => {\n      const headingText = heading[2].trim()\n      const headingType = heading[1].trim() === \"##\" ? \"h2\" : \"h3\"\n      const headingLink = slugger.slug(headingText, false)\n\n      return {\n        text: headingText,\n        id: headingLink,\n        level: headingType,\n      }\n    })\n  }\n\n  return tableOfContents\n}\n\n/**\n * Format the last edited timestamp and author from git output\n */\nfunction getTimestampAndAuthor(str: string) {\n  if (!str) return null\n\n  const GIT_COMMIT_TIMESTAMP_AUTHOR_REGEX = /^(\\d+), (.+)$/\n  const temp = str.match(GIT_COMMIT_TIMESTAMP_AUTHOR_REGEX)\n\n  if (!temp || temp.length < 3) return null\n\n  const [, timestamp, author] = temp\n  const dateStr = fromUnixTime(+timestamp)\n\n  return {\n    date: format(dateStr, \"MMMM dd, yyyy\"),\n    author,\n  }\n}\n\n/**\n * Gets the last edited timestamp and author from git\n * using `git log`\n *\n * %an = author name\n * %ct = committer date, UNIX timestamp\n *\n * @see https://git-scm.com/docs/git-log\n */\nasync function getLastEdited(filePath: string) {\n  try {\n    const { stdout } = await execa(\"git\", [\n      \"log\",\n      \"-1\",\n      \"--format=%ct, %an\",\n      filePath,\n    ])\n    return getTimestampAndAuthor(stdout)\n  } catch (error) {\n    console.error(error)\n    return null\n  }\n}\n"]},"metadata":{},"sourceType":"module"}