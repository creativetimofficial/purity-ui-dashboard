{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport * as path from \"path\";\nimport * as fs from \"fs\";\nimport { processFrontmatter, serializeMdx } from \"utils/mdx-utils\";\nimport { parseMarkdownString } from \"@docusaurus/utils\";\nimport { calcReadTime } from \"utils/calc-read-time\";\nimport siteConfig from \"../../configs/site-config\";\nexport async function loadMdx(filename) {\n  // get the `pages` directory\n  const pagesDir = path.join(process.cwd(), \"pages\"); // gets the relative mdx path\n  // pages/docs/guides.mdx => /docs/guides.mdx\n\n  const relativeFilePath = path.relative(pagesDir, filename);\n  const filePath = path.resolve(filename);\n\n  if (!fs.existsSync(filePath)) {\n    throw new Error(`can't load MDX file ${filename} in ${filePath} does not exist`);\n  }\n\n  const mdxContent = fs.readFileSync(filePath).toString(); // extract frontmatter and content from markdown string\n\n  const {\n    source: mdxSource,\n    frontMatter\n  } = await serializeMdx(mdxContent);\n  const {\n    excerpt\n  } = parseMarkdownString(mdxContent); // extends frontmatter with more useful information\n\n  return processFrontmatter(_objectSpread(_objectSpread({\n    baseEditUrl: siteConfig.repo.editUrl,\n    excerpt: frontMatter.excerpt || excerpt,\n    readTimeMinutes: calcReadTime(mdxContent),\n    mdxContent\n  }, frontMatter), {}, {\n    path: relativeFilePath,\n    mdxSource\n  }));\n}","map":{"version":3,"sources":["/Users/vladmihalache/Documents/GitHub/chakra-ui/website/src/utils/load-mdx.ts"],"names":["path","fs","processFrontmatter","serializeMdx","parseMarkdownString","calcReadTime","siteConfig","loadMdx","filename","pagesDir","join","process","cwd","relativeFilePath","relative","filePath","resolve","existsSync","Error","mdxContent","readFileSync","toString","source","mdxSource","frontMatter","excerpt","baseEditUrl","repo","editUrl","readTimeMinutes"],"mappings":";;;;;;AAAA,OAAO,KAAKA,IAAZ,MAAsB,MAAtB;AACA,OAAO,KAAKC,EAAZ,MAAoB,IAApB;AACA,SAASC,kBAAT,EAA6BC,YAA7B,QAAiD,iBAAjD;AACA,SAASC,mBAAT,QAAoC,mBAApC;AACA,SAASC,YAAT,QAA6B,sBAA7B;AACA,OAAOC,UAAP,MAAuB,2BAAvB;AAEA,OAAO,eAAeC,OAAf,CAAuBC,QAAvB,EAAyC;AAC9C;AACA,QAAMC,QAAQ,GAAGT,IAAI,CAACU,IAAL,CAAUC,OAAO,CAACC,GAAR,EAAV,EAAyB,OAAzB,CAAjB,CAF8C,CAI9C;AACA;;AACA,QAAMC,gBAAgB,GAAGb,IAAI,CAACc,QAAL,CAAcL,QAAd,EAAwBD,QAAxB,CAAzB;AAEA,QAAMO,QAAQ,GAAGf,IAAI,CAACgB,OAAL,CAAaR,QAAb,CAAjB;;AACA,MAAI,CAACP,EAAE,CAACgB,UAAH,CAAcF,QAAd,CAAL,EAA8B;AAC5B,UAAM,IAAIG,KAAJ,CACH,uBAAsBV,QAAS,OAAMO,QAAS,iBAD3C,CAAN;AAGD;;AAED,QAAMI,UAAU,GAAGlB,EAAE,CAACmB,YAAH,CAAgBL,QAAhB,EAA0BM,QAA1B,EAAnB,CAf8C,CAiB9C;;AACA,QAAM;AAAEC,IAAAA,MAAM,EAAEC,SAAV;AAAqBC,IAAAA;AAArB,MAAqC,MAAMrB,YAAY,CAACgB,UAAD,CAA7D;AAEA,QAAM;AAAEM,IAAAA;AAAF,MAAcrB,mBAAmB,CAACe,UAAD,CAAvC,CApB8C,CAsB9C;;AACA,SAAOjB,kBAAkB;AACvBwB,IAAAA,WAAW,EAAEpB,UAAU,CAACqB,IAAX,CAAgBC,OADN;AAEvBH,IAAAA,OAAO,EAAED,WAAW,CAACC,OAAZ,IAAuBA,OAFT;AAGvBI,IAAAA,eAAe,EAAExB,YAAY,CAACc,UAAD,CAHN;AAIvBA,IAAAA;AAJuB,KAKpBK,WALoB;AAMvBxB,IAAAA,IAAI,EAAEa,gBANiB;AAOvBU,IAAAA;AAPuB,KAAzB;AASD","sourcesContent":["import * as path from \"path\"\nimport * as fs from \"fs\"\nimport { processFrontmatter, serializeMdx } from \"utils/mdx-utils\"\nimport { parseMarkdownString } from \"@docusaurus/utils\"\nimport { calcReadTime } from \"utils/calc-read-time\"\nimport siteConfig from \"../../configs/site-config\"\n\nexport async function loadMdx(filename: string) {\n  // get the `pages` directory\n  const pagesDir = path.join(process.cwd(), \"pages\")\n\n  // gets the relative mdx path\n  // pages/docs/guides.mdx => /docs/guides.mdx\n  const relativeFilePath = path.relative(pagesDir, filename)\n\n  const filePath = path.resolve(filename)\n  if (!fs.existsSync(filePath)) {\n    throw new Error(\n      `can't load MDX file ${filename} in ${filePath} does not exist`,\n    )\n  }\n\n  const mdxContent = fs.readFileSync(filePath).toString()\n\n  // extract frontmatter and content from markdown string\n  const { source: mdxSource, frontMatter } = await serializeMdx(mdxContent)\n\n  const { excerpt } = parseMarkdownString(mdxContent)\n\n  // extends frontmatter with more useful information\n  return processFrontmatter({\n    baseEditUrl: siteConfig.repo.editUrl,\n    excerpt: frontMatter.excerpt || excerpt,\n    readTimeMinutes: calcReadTime(mdxContent),\n    mdxContent,\n    ...frontMatter,\n    path: relativeFilePath,\n    mdxSource,\n  })\n}\n"]},"metadata":{},"sourceType":"module"}